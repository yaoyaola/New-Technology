********************************************** ArrayList,Vector ************************************************************
ArrayList就是一个以数组形式实现的集合

ArrayList四个关注点

关注点	                        结论
ArrayList是否允许空	           允许
ArrayList是否允许重复数据	      允许
ArrayList是否有序	             有序
ArrayList是否线程安全	         非线程安全


ArrayList提供了三个构造函数：
ArrayList()：默认构造函数，提供初始容量为10的空列表。
ArrayList(int initialCapacity)：构造一个具有指定初始容量的空列表。
ArrayList(Collection<? extends E> c)：构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。

/**
 * 构造一个初始容量为 10 的空列表
 */
public ArrayList() {
    this(10);
}

/**
 * 构造一个具有指定初始容量的空列表。
 */
public ArrayList(int initialCapacity) {
    super();
    if (initialCapacity < 0)
        throw new IllegalArgumentException("Illegal Capacity: "
                + initialCapacity);
    this.elementData = new Object[initialCapacity];
}

/**
 *  构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。
 */
public ArrayList(Collection<? extends E> c) {
    elementData = c.toArray();
    size = elementData.length;
    // c.toArray might (incorrectly) not return Object[] (see 6260652)
    if (elementData.getClass() != Object[].class)
        elementData = Arrays.copyOf(elementData, size, Object[].class);
}


添加元素的时候，到底在干什么
public boolean add(E e) {
     ensureCapacity(size + 1);  // Increments modCount!!
     elementData[size++] = e;
     return true;
}

ensureCapacity方法是扩容用的
底层实际上在调用add方法的时候只是给elementData的某个位置添加了一个数据而已
elementData中存储的应该是堆内存中元素的引用，而不是实际的元素

扩容
构造ArrayList的时候，默认的底层数组大小是10：
public ArrayList() {
     this(10);
}
底层数组的大小不够了怎么办？扩容，
这也就是为什么一直说ArrayList的底层是基于动态数组实现的原因，
动态数组的意思就是指底层的数组大小并不是固定的，而是根据添加的元素大小进行一个判断，不够的话就动态扩容，扩容的代码就在ensureCapacity里面：
public void ensureCapacity(int minCapacity) {
    modCount++;
    int oldCapacity = elementData.length;
    if (minCapacity > oldCapacity) {
        Object oldData[] = elementData;
        int newCapacity = (oldCapacity * 3)/2 + 1;
            if (newCapacity < minCapacity)
        newCapacity = minCapacity;
               // minCapacity is usually close to size, so this is a win:
               elementData = Arrays.copyOf(elementData, newCapacity);
    }
}

看到扩容的时候把元素组大小先乘以3，再除以2，最后加1。为什么？我们可以想：
1、如果一次性扩容扩得太大，必然造成内存空间的浪费
2、如果一次性扩容扩得不够，那么下一次扩容的操作必然比较快地会到来，这会降低程序运行效率，要知道扩容还是比价耗费性能的一个操作

所以扩容扩多少，是JDK开发人员在时间、空间上做的一个权衡，提供出来的一个比较合理的数值。最后调用到的是Arrays的copyOf方法，
将元素组里面的内容复制到新的数组里面去：

public static <T,U> T[] copyOf(U[] original, int newLength, Class<? extends T[]> newType) {
       T[] copy = ((Object)newType == (Object)Object[].class)
           ? (T[]) new Object[newLength]
           : (T[]) Array.newInstance(newType.getComponentType(), newLength);
       System.arraycopy(original, 0, copy, 0,
                        Math.min(original.length, newLength));
       return copy;
}

插入元素
看一下ArrayList的插入操作，插入操作调用的也是add方法
其中：
list.add(2, "000");
往第几个元素后面插入一个元素

插入元素的时候做了什么：
// 将指定的元素插入此列表中的指定位置。  
// 如果当前位置有元素，则向右移动当前位于该位置的元素以及所有后续元素（将其索引加1）。  
public void add(int index, E element) {  
   if (index > size || index < 0)  
       throw new IndexOutOfBoundsException("Index: "+index+", Size: "+size);  
   // 如果数组长度不足，将进行扩容。  
   ensureCapacity(size+1);  // Increments modCount!!  
   // 将 elementData中从Index位置开始、长度为size-index的元素，  
   // 拷贝到从下标为index+1位置开始的新的elementData数组中。  
   // 即将当前位于该位置的元素以及所有后续元素右移一个位置。  
   System.arraycopy(elementData, index, elementData, index + 1, size - index);  
   elementData[index] = element;  
   size++;  
}

看到插入的时候，按照指定位置，把从指定位置开始的所有元素利用System.arraycopy方法做一个整体的复制，
向后移动一个位置（当然先要用ensureCapacity方法进行判断，加了一个元素之后数组会不会不够大），然后指定位置的元素设置为需要插入的元素，
完成了一次插入的操作。


删除元素
ArrayList支持两种删除方式：
1、按照下标删除
2、按照元素删除，这会删除ArrayList中与指定要删除的元素匹配的第一个元素
对于ArrayList来说，这两种删除的方法差不多，都是调用的下面一段代码：
int numMoved = size - index - 1;
if (numMoved > 0)
    System.arraycopy(elementData, index+1, elementData, index,
             numMoved);
elementData[--size] = null; // Let gc do its work

其实做的事情就是两件:
1、把指定元素后面位置的所有元素，利用System.arraycopy方法整体向前移动一个位置
2、最后一个位置的元素指定为null，这样让gc可以去回收它

ArrayList的优缺点
从上面的几个过程总结一下ArrayList的优缺点。ArrayList的优点如下：
1、ArrayList底层以数组实现，是一种随机访问模式，再加上它实现了RandomAccess接口，因此查找也就是get的时候非常快。
2、ArrayList在顺序添加一个元素的时候非常方便，只是往数组里面添加了一个元素而已。

不过ArrayList的缺点也十分明显：
1、删除元素的时候，涉及到一次元素复制，如果要复制的元素很多，那么就会比较耗费性能。
2、插入元素的时候，涉及到一次元素复制，如果要复制的元素很多，那么就会比较耗费性能。
因此，ArrayList比较适合顺序添加、随机访问的场景。

ArrayList是线程非安全的，这很明显，因为ArrayList中所有的方法都不是同步的，在并发下一定会出现线程安全问题。
那么我们想要使用ArrayList并且让它线程安全怎么办？一个方法是用Collections.synchronizedList方法把你的ArrayList变成一个线程安全的List，比如：
List<String> synchronizedList = Collections.synchronizedList(list);
synchronizedList.add("aaa");
synchronizedList.add("bbb");
for (int i = 0; i < synchronizedList.size(); i++)
{
    System.out.println(synchronizedList.get(i));
}

另一个方法就是Vector，它是ArrayList的线程安全版本，其实现90%和ArrayList都完全一样，区别在于：
1、Vector是线程安全的，ArrayList是线程非安全的
2、Vector可以指定增长因子，如果该增长因子指定了，那么扩容的时候会每次新的数组大小会在原数组的大小基础上加上增长因子；如果不指定增长因子，
   那么就给原数组大小*2，源代码是这样的：
int newCapacity = oldCapacity + ((capacityIncrement > 0) ?capacityIncrement : oldCapacity);


总结
ArrayList基于数组实现，可以通过下标索引直接查找到指定位置的元素，因此查找效率高，但每次插入或删除元素，就要大量地移动元素，插入删除元素的效率低。

********************************************** ArrayList,Vector ************************************************************

************************************************** LinkedList **************************************************************
LinkedList底层的数据结构是基于双向循环链表的，且头结点中不存放数据,如下：

----------------------------------------------------------------------------------------
|(before)header(after)| - |(before)position(after)| - |(before)position(after)|.........
----------------------------------------------------------------------------------------

什么是链表
链表原先是C/C++的概念，是一种线性的存储结构，意思是将要存储的数据存在一个存储单元里面，这个存储单元里面除了存放有待存储的数据以外，
还存储有其下一个存储单元的地址（下一个存储单元的地址是必要的，有些存储结构还存放有其前一个存储单元的地址），每次查找数据的时候，
通过某个存储单元中的下一个存储单元的地址寻找其后面的那个存储单元。

LinkedList是一种双向链表，双向链表有两点含义：
1、链表中任意一个存储单元都可以通过向前或者向后寻址的方式获取到其前一个存储单元和其后一个存储单元
2、链表的尾节点的后一个节点是链表的头结点，链表的头结点的前一个节点是链表的尾节点

既然是双向链表，那么必定存在一种数据结构——我们可以称之为节点，节点实例保存业务数据、前一个节点的位置信息和后一个节点位置信息


私有属性
LinkedList中定义了两个私有属性：

private transient Entry<E> header = new Entry<E>(null, null, null);

private transient int size = 0;


************************************************** LinkedList **************************************************************
